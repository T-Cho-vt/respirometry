classdef matrixHfun
    %
    % matrixHfun class
    %
    % A matrixHfun object is used to represent a toeplitz matrix H in
    % matrix-vector multiplication where the matrix is generated by 
    % impulse response vector h
    %
    % The matrixHfun has input(s):
    %   h - impulse response vector
    %   cond - boundary conditions {'zero'|'periodic'|'reflexive'}
    %   f - sampling frequency (e.g., 10Hz)
    %
    % and is based on a structure with the following fields:
    %
    % Calling Syntax:
    %   P = matrixHfun(h,cond,f)
    %
    % T.Cho, 4/26/2020
    
    properties
        h
        f
        cond
        transpose
    end
    
    methods
        
        function P = matrixHfun(varargin) % constructor
            switch nargin
                case 3
                    P.transpose = false;
                    P.h = varargin{1};
                    P.cond = varargin{2};
                    P.f = varargin{3};
                otherwise
                    error('Incorrect number of input arguments')
            end % switch
        end 
        
    
    
        function P = ctranspose(P) % Overload transpose
            P.transpose = not(P.transpose); % switches boolean trnaspose flag
        end % transpose
    
        function y = mtimes(H,x)
            
            size2 = size(x,2);
            y = [];    
            
            if H.transpose
                switch H.cond
                    case 'zero'        
                        for i = 1:size2
                            n = length(H.h);
                            v = [zeros(n-1,1); H.h]/H.f;
                            y = [y, conv(flipud(v),x(:,i),'valid')];
                        end
                    case 'periodic'
                        for i = 1:size2
                            n = length(H.h);
                            v = [zeros(n-1,1); H.h]/H.f;
                            vx = conv(flipud(v),x(:,i),'valid');
                            w = flipud([zeros(n,1);flipud(H.h(2:end))]);
                            wx = flipud(conv(w,flipud(x(:,i)),'valid'));
                            y = [y, vx+wx];
                        end
                    case 'reflexive'
                        for i = 1:size2
                            n = length(H.h);
                            v = [zeros(n-1,1); H.h]/H.f;
                            vx = conv(flipud(v),x(:,i),'valid');
                            w = [zeros(n,1); flipud(H.h(2:end))]/H.f;
                            wx = flipud(conv(w,x(:,i),'valid'));
                            y = [y, vx+wx];
                        end
                end
            else
                switch H.cond
                    case 'zero'                        
                        for i = 1:size2
                            n = length(H.h);
                            v = [zeros(n-1,1);H.h]/H.f;
                            y = [y, conv(v,x(:,i),'valid')];
                        end
                    case 'periodic'
                        for i = 1:size2
                            n = length(H.h);
                            v = [zeros(n-1,1);H.h]/H.f;
                            vx = conv(v,x(:,i),'valid');
                            w = [zeros(n,1); flipud(H.h(2:end))]/H.f;
                            wx = flipud(conv(w,flipud(x(:,i)),'valid'));
                            y = [y, vx+wx];
                        end
                    case 'reflexive'
                        for i = 1:size2
                            n = length(H.h);
                            v = [zeros(n-1,1);H.h]/H.f;
                            vx = conv(v,x(:,i),'valid');
                            w = [zeros(n,1); flipud(H.h(2:end))]/H.f;
                            wx = flipud(conv(w,x(:,i),'valid'));
                            y = [y, vx+wx];
                        end
                end
            end
        end % mtimes

        function varargout = size(H,dim)
            d(1) = length(H.h);
            d(2) = length(H.h);

            if nargout == 1 || nargout == 0
                if nargin >1
                    varargout{1} = d(dim);
                else
                    varargout{1} = d;
                end
            else
                varargout{1} = d(1);
                varargout{2} = d(2);
            end
        end % size
        
        function l = length(H)
            l = length(H.h);
        end % length
        
    end % methods
end % classdef